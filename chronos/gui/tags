!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.5.4	//
ANSI_SYMCAT	host.h	72;"	d
ANSI_SYMCAT	host.h	78;"	d
BCODE	machine.h	326;"	d
BS	machine.h	332;"	d
CC	Makefile	/^CC=gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS= -O2$/;"	m
CONNECT	machine.c	115;"	d	file:
CONNECT	machine.c	72;"	d	file:
CONNECT	machine.c	81;"	d	file:
CONNECT	machine.c	90;"	d	file:
CONNECT	machine.h	236;"	d
DEFINST	machine.c	113;"	d	file:
DEFINST	machine.c	565;"	d	file:
DEFINST	machine.c	70;"	d	file:
DEFINST	machine.c	79;"	d	file:
DEFINST	machine.c	88;"	d	file:
DEFINST	machine.h	234;"	d
DEFLINK	machine.c	114;"	d	file:
DEFLINK	machine.c	71;"	d	file:
DEFLINK	machine.c	80;"	d	file:
DEFLINK	machine.c	89;"	d	file:
DEFLINK	machine.h	235;"	d
DIS	Makefile	/^DIS=dis$/;"	m
DIV0	machine.h	758;"	d
DIV0	machine.h	774;"	d
DOTSEEN	misc.c	448;"	d	file:
ECOFF_EB_MAGIC	ecoff.h	98;"	d
ECOFF_EL_MAGIC	ecoff.h	99;"	d
ECOFF_H	ecoff.h	96;"	d
ECOFF_R_SN_BSS	ecoff.h	232;"	d
ECOFF_R_SN_DATA	ecoff.h	229;"	d
ECOFF_R_SN_RDATA	ecoff.h	228;"	d
ECOFF_R_SN_SBSS	ecoff.h	231;"	d
ECOFF_R_SN_SDATA	ecoff.h	230;"	d
ECOFF_R_SN_TEXT	ecoff.h	227;"	d
ECOFF_STYP_BSS	ecoff.h	239;"	d
ECOFF_STYP_DATA	ecoff.h	236;"	d
ECOFF_STYP_RDATA	ecoff.h	235;"	d
ECOFF_STYP_SBSS	ecoff.h	238;"	d
ECOFF_STYP_SDATA	ecoff.h	237;"	d
ECOFF_STYP_TEXT	ecoff.h	234;"	d
ECOFF_magicSym	ecoff.h	167;"	d
ECOFF_stBlock	ecoff.h	248;"	d
ECOFF_stConstant	ecoff.h	256;"	d
ECOFF_stEnd	ecoff.h	249;"	d
ECOFF_stFile	ecoff.h	252;"	d
ECOFF_stForward	ecoff.h	254;"	d
ECOFF_stGlobal	ecoff.h	242;"	d
ECOFF_stLabel	ecoff.h	246;"	d
ECOFF_stLocal	ecoff.h	245;"	d
ECOFF_stMember	ecoff.h	250;"	d
ECOFF_stNil	ecoff.h	241;"	d
ECOFF_stParam	ecoff.h	244;"	d
ECOFF_stProc	ecoff.h	247;"	d
ECOFF_stRegReloc	ecoff.h	253;"	d
ECOFF_stStatic	ecoff.h	243;"	d
ECOFF_stStaticProc	ecoff.h	255;"	d
ECOFF_stTypedef	ecoff.h	251;"	d
ERR_BADCONST	eval.h	/^  ERR_BADCONST,			\/* badly formed constant *\/$/;"	e	enum:eval_err_t
ERR_BADEXPR	eval.h	/^  ERR_BADEXPR,			\/* badly formed constant *\/$/;"	e	enum:eval_err_t
ERR_DIV0	eval.h	/^  ERR_DIV0,			\/* divide by zero *\/$/;"	e	enum:eval_err_t
ERR_EXTRA	eval.h	/^  ERR_EXTRA,			\/* extra characters at end of expression *\/$/;"	e	enum:eval_err_t
ERR_NOERR	eval.h	/^  ERR_NOERR,			\/* no error *\/$/;"	e	enum:eval_err_t
ERR_NOTERM	eval.h	/^  ERR_NOTERM,			\/* expression term is missing *\/$/;"	e	enum:eval_err_t
ERR_NUM	eval.h	/^  ERR_NUM$/;"	e	enum:eval_err_t
ERR_UNDEFVAR	eval.h	/^  ERR_UNDEFVAR,			\/* variable is undefined *\/$/;"	e	enum:eval_err_t
ERR_UPAREN	eval.h	/^  ERR_UPAREN,			\/* unmatched parenthesis *\/$/;"	e	enum:eval_err_t
EVAL_H	eval.h	53;"	d
EVAL_INTEGRAL	eval.h	131;"	d
EVAL_INTEGRAL	eval.h	135;"	d
FALSE	misc.h	68;"	d
FD	machine.h	314;"	d
FDIV	machine.h	784;"	d
FINT	machine.h	785;"	d
FPALIGN	machine.h	765;"	d
FPALIGN	machine.h	776;"	d
FS	machine.h	312;"	d
FT	machine.h	313;"	d
FUClass_NA	machine.h	/^  FUClass_NA = 0,	\/* inst does not use a functional unit *\/$/;"	e	enum:md_fu_class
F_CALL	machine.h	294;"	d
F_COND	machine.h	283;"	d
F_CTRL	machine.h	281;"	d
F_DIRECT	machine.h	289;"	d
F_DIRJMP	machine.h	292;"	d
F_DISP	machine.h	287;"	d
F_FCOMP	machine.h	280;"	d
F_FPCOND	machine.h	295;"	d
F_ICOMP	machine.h	279;"	d
F_IMM	machine.h	296;"	d
F_INDIRJMP	machine.h	293;"	d
F_LOAD	machine.h	285;"	d
F_LONGLAT	machine.h	291;"	d
F_MEM	machine.h	284;"	d
F_RR	machine.h	288;"	d
F_STORE	machine.h	286;"	d
F_TRAP	machine.h	290;"	d
F_UNCOND	machine.h	282;"	d
FloatADD	machine.h	/^  FloatADD,		\/* floating point adder\/subtractor *\/$/;"	e	enum:md_fu_class
FloatCMP	machine.h	/^  FloatCMP,		\/* floating point comparator *\/$/;"	e	enum:md_fu_class
FloatCVT	machine.h	/^  FloatCVT,		\/* floating point<->integer converter *\/$/;"	e	enum:md_fu_class
FloatDIV	machine.h	/^  FloatDIV,		\/* floating point divider *\/$/;"	e	enum:md_fu_class
FloatMULT	machine.h	/^  FloatMULT,		\/* floating point multiplier *\/$/;"	e	enum:md_fu_class
FloatSQRT	machine.h	/^  FloatSQRT,		\/* floating point square root *\/$/;"	e	enum:md_fu_class
HIBITL	misc.c	395;"	d	file:
HIBITL	misc.c	399;"	d	file:
HOST_H	host.h	53;"	d
HOST_HAS_QWORD	host.h	106;"	d
HOST_HAS_QWORD	host.h	117;"	d
HOST_HAS_QWORD	host.h	123;"	d
HOST_HAS_QWORD	host.h	95;"	d
IDIV	machine.h	782;"	d
IFAIL	machine.h	754;"	d
IMM	machine.h	317;"	d
IMOD	machine.h	783;"	d
INC_DEC	machine.h	729;"	d
INLINE	host.h	61;"	d
INLINE	host.h	63;"	d
INLINE	host.h	65;"	d
INTALIGN	machine.h	761;"	d
INTALIGN	machine.h	775;"	d
IntALU	machine.h	/^  IntALU,		\/* integer ALU *\/$/;"	e	enum:md_fu_class
IntDIV	machine.h	/^  IntDIV,		\/* integer divider *\/$/;"	e	enum:md_fu_class
IntMULT	machine.h	/^  IntMULT,		\/* integer multiplier *\/$/;"	e	enum:md_fu_class
LENGTH	misc.c	449;"	d	file:
LL	host.h	100;"	d
LL	host.h	103;"	d
LL	host.h	111;"	d
LL	host.h	114;"	d
LL	host.h	121;"	d
LLHIGH	misc.h	80;"	d
LLLOW	misc.h	81;"	d
LL_MAX	misc.c	787;"	d	file:
LL_MIN	misc.c	788;"	d	file:
LZERO	misc.c	447;"	d	file:
MAX	misc.h	73;"	d
MAXDIGS	misc.c	453;"	d	file:
MAXINT_VAL	machine.h	335;"	d
MD_AGEN_OP	machine.h	645;"	d
MD_AMODE_POSTPROBE	machine.h	477;"	d
MD_AMODE_PREPROBE	machine.h	451;"	d
MD_AMODE_PROBE	machine.h	455;"	d
MD_BR_SHIFT	machine.h	663;"	d
MD_CROSS_ENDIAN	machine.h	82;"	d
MD_CROSS_ENDIAN	machine.h	85;"	d
MD_DATA_BASE	machine.h	212;"	d
MD_EIO_FILE_FORMAT	machine.h	486;"	d
MD_EXIT_SYSCALL	machine.h	416;"	d
MD_EXO_CMP_IREG	machine.h	539;"	d
MD_EXO_TO_FREG	machine.h	536;"	d
MD_EXO_TO_IREG	machine.h	533;"	d
MD_EXO_TO_MISC_REGS	machine.h	504;"	d
MD_FETCH_INST	machine.h	202;"	d
MD_FIRST_IN_REG	machine.h	542;"	d
MD_FIRST_OUT_REG	machine.h	545;"	d
MD_FREG_TO_EXO	machine.h	501;"	d
MD_FU_NAME	machine.h	275;"	d
MD_IREG_TO_EXO	machine.h	498;"	d
MD_IS_CALL	machine.h	429;"	d
MD_IS_INDIR	machine.h	436;"	d
MD_IS_RETURN	machine.h	433;"	d
MD_LAST_IN_REG	machine.h	543;"	d
MD_LAST_OUT_REG	machine.h	546;"	d
MD_LOG_PAGE_SIZE	machine.h	108;"	d
MD_MAX_ENVIRON	machine.h	216;"	d
MD_MAX_MASK	machine.h	229;"	d
MD_MISC_REGS_TO_EXO	machine.h	488;"	d
MD_NOP_INST	machine.c	/^md_inst_t MD_NOP_INST = { NOP, 0 };$/;"	v
MD_NOP_OP	machine.h	648;"	d
MD_NUM_CREGS	machine.h	138;"	d
MD_NUM_FREGS	machine.h	135;"	d
MD_NUM_IREGS	machine.h	132;"	d
MD_OPFIELD	machine.h	224;"	d
MD_OP_ENUM	machine.h	242;"	d
MD_OP_FLAGS	machine.h	299;"	d
MD_OP_FORMAT	machine.h	250;"	d
MD_OP_FUCLASS	machine.h	271;"	d
MD_OP_NAME	machine.h	246;"	d
MD_OUTPUT_SYSCALL	machine.h	420;"	d
MD_PAGE_SIZE	machine.h	107;"	d
MD_QWORD_ADDRS	machine.h	96;"	d
MD_REG_FP	machine.h	/^  MD_REG_FP = 30	\/* frame pointer *\/$/;"	e	enum:md_reg_names
MD_REG_GP	machine.h	/^  MD_REG_GP = 28,	\/* global data section pointer *\/$/;"	e	enum:md_reg_names
MD_REG_SP	machine.h	/^  MD_REG_SP = 29,	\/* stack pointer *\/$/;"	e	enum:md_reg_names
MD_REG_ZERO	machine.h	/^  MD_REG_ZERO = 0,	\/* zero register *\/$/;"	e	enum:md_reg_names
MD_SET_OPCODE	machine.h	225;"	d
MD_STACK_BASE	machine.h	213;"	d
MD_STREAM_FILENO	machine.h	426;"	d
MD_SWAPD	machine.h	196;"	d
MD_SWAPH	machine.h	185;"	d
MD_SWAPH	machine.h	193;"	d
MD_SWAPI	machine.h	188;"	d
MD_SWAPI	machine.h	197;"	d
MD_SWAPQ	machine.h	187;"	d
MD_SWAPQ	machine.h	195;"	d
MD_SWAPW	machine.h	186;"	d
MD_SWAPW	machine.h	194;"	d
MD_TEXT_BASE	machine.h	211;"	d
MD_TOTAL_REGS	machine.h	141;"	d
MD_VALID_ADDR	machine.h	652;"	d
MIN	misc.h	76;"	d
MISC_H	misc.h	53;"	d
NA	machine.h	89;"	d
NUM_FU_CLASSES	machine.h	/^  NUM_FU_CLASSES	\/* total functional unit classes *\/$/;"	e	enum:md_fu_class
N_ELT	misc.h	84;"	d
OBJECTS	Makefile	/^OBJECTS=main.o machine.o misc.o readfile.o  symbol.o eval.o$/;"	m
OFS	machine.h	329;"	d
OP_MAX	machine.h	/^  OP_MAX	\/* number of opcodes + NA *\/$/;"	e	enum:md_opcode
OP_NA	machine.h	/^  OP_NA = 0,	\/* NA *\/$/;"	e	enum:md_opcode
OVER	machine.h	338;"	d
OVER	machine.h	772;"	d
PAD	misc.c	385;"	d	file:
PADZERO	misc.c	445;"	d	file:
PISA_H	machine.h	53;"	d
POLYNOMIAL	misc.c	1148;"	d	file:
PUT	misc.c	374;"	d	file:
RD	machine.h	306;"	d
READ_FILE_H	readfile.h	25;"	d
REGS_H	regs.h	53;"	d
RELEVANT_SCOPE	symbol.c	201;"	d	file:
ROUND_DOWN	misc.h	88;"	d
ROUND_UP	misc.h	87;"	d
RS	machine.h	303;"	d
RS	machine.h	304;"	d
RT	machine.h	305;"	d
RZERO	misc.c	446;"	d	file:
RdPort	machine.h	/^  RdPort,		\/* memory read port *\/$/;"	e	enum:md_fu_class
Rfp	machine.h	741;"	d
Rgp	machine.h	739;"	d
Rsp	machine.h	740;"	d
SET_TPC	machine.h	349;"	d
SHAMT	machine.h	309;"	d
SS_COMP_NOP	machine.h	714;"	d
SS_COMP_OP	machine.h	711;"	d
SS_COMP_POST_DBL_DEC	machine.h	720;"	d
SS_COMP_POST_DBL_INC	machine.h	719;"	d
SS_COMP_POST_DEC	machine.h	716;"	d
SS_COMP_POST_INC	machine.h	715;"	d
SS_COMP_PRE_DBL_DEC	machine.h	722;"	d
SS_COMP_PRE_DBL_INC	machine.h	721;"	d
SS_COMP_PRE_DEC	machine.h	718;"	d
SS_COMP_PRE_INC	machine.h	717;"	d
SS_NUM_REGS	machine.h	703;"	d
SS_PAGE_SIZE	machine.h	700;"	d
SS_SYS_exit	machine.h	415;"	d
SS_SYS_write	machine.h	419;"	d
SS_TOTAL_REGS	machine.h	706;"	d
SYMBOL_H	symbol.h	53;"	d
SYMCAT	host.h	71;"	d
SYMCAT	host.h	75;"	d
SYMCAT	host.h	77;"	d
TALIGN	machine.h	769;"	d
TALIGN	machine.h	777;"	d
TARG	machine.h	323;"	d
TARGET_PISA	machine.h	67;"	d
TARGET_PISA_BIG	machine.h	73;"	d
TARGET_PISA_LITTLE	machine.h	75;"	d
TEXT_TAIL_PADDING	readfile.c	35;"	d	file:
TRUE	misc.h	65;"	d
UIMM	machine.h	320;"	d
ULL	host.h	102;"	d
ULL	host.h	110;"	d
ULL	host.h	113;"	d
ULL	host.h	120;"	d
ULL	host.h	99;"	d
ULL_MAX	misc.c	789;"	d	file:
UNDER	machine.h	343;"	d
UNDER	machine.h	773;"	d
WL_BASE	machine.h	355;"	d
WL_BASE	machine.h	369;"	d
WL_BASE	machine.h	388;"	d
WL_BASE	machine.h	398;"	d
WL_PROT_MASK	machine.h	356;"	d
WL_PROT_MASK	machine.h	370;"	d
WL_PROT_MASK	machine.h	389;"	d
WL_PROT_MASK1	machine.h	357;"	d
WL_PROT_MASK1	machine.h	371;"	d
WL_PROT_MASK1	machine.h	399;"	d
WL_PROT_MASK2	machine.h	358;"	d
WL_PROT_MASK2	machine.h	372;"	d
WL_PROT_MASK2	machine.h	400;"	d
WL_SIZE	machine.h	354;"	d
WL_SIZE	machine.h	368;"	d
WL_SIZE	machine.h	387;"	d
WL_SIZE	machine.h	397;"	d
WR_BASE	machine.h	362;"	d
WR_BASE	machine.h	376;"	d
WR_BASE	machine.h	393;"	d
WR_BASE	machine.h	404;"	d
WR_PROT_MASK	machine.h	363;"	d
WR_PROT_MASK	machine.h	377;"	d
WR_PROT_MASK	machine.h	394;"	d
WR_PROT_MASK1	machine.h	364;"	d
WR_PROT_MASK1	machine.h	378;"	d
WR_PROT_MASK1	machine.h	405;"	d
WR_PROT_MASK2	machine.h	365;"	d
WR_PROT_MASK2	machine.h	379;"	d
WR_PROT_MASK2	machine.h	406;"	d
WR_SIZE	machine.h	361;"	d
WR_SIZE	machine.h	375;"	d
WR_SIZE	machine.h	392;"	d
WR_SIZE	machine.h	403;"	d
WrPort	machine.h	/^  WrPort,		\/* memory write port *\/$/;"	e	enum:md_fu_class
XX	machine.c	689;"	d	file:
_debug	misc.c	/^_debug(char *file, char *func, int line, char *fmt, ...)$/;"	f
_info	misc.c	/^_info(char *file, char *func, int line, char *fmt, ...)$/;"	f
_lowdigit	misc.c	/^_lowdigit(slargeint_t *valptr)$/;"	f	file:
_warn	misc.c	/^_warn(char *file, char *func, int line, char *fmt, ...)$/;"	f
a	machine.h	/^  word_t a;		\/* simplescalar opcode (must be unsigned) *\/$/;"	m
a_double	eval.c	/^static struct eval_value_t a_double;$/;"	v	file:
a_float	eval.c	/^static struct eval_value_t a_float;$/;"	v	file:
a_symbol	eval.c	/^static struct eval_value_t a_symbol;$/;"	v	file:
a_uint	eval.c	/^static struct eval_value_t a_uint;$/;"	v	file:
acmp	symbol.c	/^acmp(struct sym_sym_t **sym1, struct sym_sym_t **sym2)$/;"	f	file:
addr	symbol.h	/^  md_addr_t addr;		\/* symbol address value *\/$/;"	m	struct:sym_sym_t
adr	ecoff.h	/^  unsigned int adr;$/;"	m	struct:ecoff_fdr
adr	ecoff.h	/^  unsigned int adr;$/;"	m	struct:ecoff_pdr
an_int	eval.c	/^static struct eval_value_t an_int;$/;"	v	file:
as_addr	eval.h	/^    md_addr_t as_addr;			\/* value for type == et_addr *\/$/;"	m	union:eval_value_t::<anonymous>
as_double	eval.h	/^    double as_double;			\/* value for type == et_double *\/$/;"	m	union:eval_value_t::<anonymous>
as_float	eval.h	/^    float as_float;			\/* value for type == et_float *\/$/;"	m	union:eval_value_t::<anonymous>
as_int	eval.h	/^    int as_int;				\/* value for type == et_int *\/$/;"	m	union:eval_value_t::<anonymous>
as_qword	eval.h	/^    qword_t as_qword;			\/* value for type == ec_qword *\/$/;"	m	union:eval_value_t::<anonymous>
as_sqword	eval.h	/^    sqword_t as_sqword;			\/* value for type == ec_sqword *\/$/;"	m	union:eval_value_t::<anonymous>
as_symbol	eval.h	/^    char *as_symbol;			\/* value for type == et_symbol *\/$/;"	m	union:eval_value_t::<anonymous>
as_uint	eval.h	/^    unsigned int as_uint;		\/* value for type == et_uint *\/$/;"	m	union:eval_value_t::<anonymous>
asym	ecoff.h	/^  ecoff_SYMR asym;$/;"	m	struct:ecoff_EXTR
b	machine.h	/^  word_t b;		\/* simplescalar unsigned immediate fields *\/$/;"	m
bool_t	host.h	/^typedef int bool_t;			\/* generic boolean type *\/$/;"	t
bsize	ecoff.h	/^  int bsize;$/;"	m	struct:ecoff_aouthdr
bss_start	ecoff.h	/^  int bss_start;$/;"	m	struct:ecoff_aouthdr
byte_t	host.h	/^typedef unsigned char byte_t;		\/* byte - 8 bits *\/$/;"	t
caux	ecoff.h	/^  int caux;$/;"	m	struct:ecoff_fdr
cbAuxOffset	ecoff.h	/^  int cbAuxOffset;$/;"	m	struct:ecoff_symhdr_t
cbDnOffset	ecoff.h	/^  int cbDnOffset;$/;"	m	struct:ecoff_symhdr_t
cbExtOffset	ecoff.h	/^  int cbExtOffset;$/;"	m	struct:ecoff_symhdr_t
cbFdOffset	ecoff.h	/^  int cbFdOffset;$/;"	m	struct:ecoff_symhdr_t
cbLine	ecoff.h	/^  int cbLine;$/;"	m	struct:ecoff_fdr
cbLine	ecoff.h	/^  int cbLine;$/;"	m	struct:ecoff_symhdr_t
cbLineOffset	ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_fdr
cbLineOffset	ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_pdr
cbLineOffset	ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_symhdr_t
cbOptOffset	ecoff.h	/^  int cbOptOffset;$/;"	m	struct:ecoff_symhdr_t
cbPdOffset	ecoff.h	/^  int cbPdOffset;$/;"	m	struct:ecoff_symhdr_t
cbRfdOffset	ecoff.h	/^  int cbRfdOffset;$/;"	m	struct:ecoff_symhdr_t
cbSs	ecoff.h	/^  int cbSs;$/;"	m	struct:ecoff_fdr
cbSsExtOffset	ecoff.h	/^  int cbSsExtOffset;$/;"	m	struct:ecoff_symhdr_t
cbSsOffset	ecoff.h	/^  int cbSsOffset;$/;"	m	struct:ecoff_symhdr_t
cbSymOffset	ecoff.h	/^  int cbSymOffset;$/;"	m	struct:ecoff_symhdr_t
cline	ecoff.h	/^  int cline;$/;"	m	struct:ecoff_fdr
cmd	misc.c	/^  char *cmd;$/;"	m	file:
code_size	readfile.c	/^int		code_size;$/;"	v
constant	eval.c	/^constant(struct eval_state_t *es)	\/* expression evaluator *\/$/;"	f	file:
copt	ecoff.h	/^  int copt;$/;"	m	struct:ecoff_fdr
counter_t	host.h	/^typedef dfloat_t counter_t;$/;"	t
counter_t	host.h	/^typedef sqword_t counter_t;$/;"	t
cpd	ecoff.h	/^  unsigned short cpd;$/;"	m	struct:ecoff_fdr
cprmask	ecoff.h	/^  int cprmask[4];$/;"	m	struct:ecoff_aouthdr
crc	misc.c	/^crc(word_t crc_accum, word_t data)$/;"	f
crc_gentab	misc.c	/^crc_gentab(void)$/;"	f	file:
crc_init	misc.c	/^static int crc_init = FALSE;$/;"	v	file:
crc_table	misc.c	/^static unsigned long crc_table[256];$/;"	v	file:
crfd	ecoff.h	/^  int crfd;$/;"	m	struct:ecoff_fdr
crfd	ecoff.h	/^  int crfd;$/;"	m	struct:ecoff_symhdr_t
csym	ecoff.h	/^  int csym;$/;"	m	struct:ecoff_fdr
d	machine.h	/^  dfloat_t d[MD_NUM_FREGS\/2];	\/* double-prediction floating point view *\/$/;"	m
data_start	ecoff.h	/^  int data_start;$/;"	m	struct:ecoff_aouthdr
debug	misc.h	/^static void debug(char *fmt, ...) {}$/;"	f
debug	misc.h	158;"	d
debug	misc.h	174;"	d
debugging	misc.c	/^int debugging = FALSE;$/;"	v
decode_function	readfile.c	/^void decode_function(FILE * fdis, md_inst_t inst,md_addr_t pc){$/;"	f
detect_ij	readfile.c	/^void detect_ij(md_addr_t pc, md_inst_t inst){$/;"	f
dfloat_t	host.h	/^typedef double dfloat_t;		\/* double-precision float - 64 bits *\/$/;"	t
dsize	ecoff.h	/^  int dsize;$/;"	m	struct:ecoff_aouthdr
ecoff_EXTR	ecoff.h	/^typedef struct ecoff_EXTR {$/;"	s
ecoff_EXTR	ecoff.h	/^} ecoff_EXTR;$/;"	t
ecoff_FDR	ecoff.h	/^} ecoff_FDR;$/;"	t
ecoff_HDRR	ecoff.h	/^} ecoff_HDRR;$/;"	t
ecoff_PDR	ecoff.h	/^} ecoff_PDR;$/;"	t
ecoff_SYMR	ecoff.h	/^typedef struct ecoff_SYMR {$/;"	s
ecoff_SYMR	ecoff.h	/^} ecoff_SYMR;$/;"	t
ecoff_aouthdr	ecoff.h	/^struct ecoff_aouthdr {$/;"	s
ecoff_fdr	ecoff.h	/^typedef struct ecoff_fdr {$/;"	s
ecoff_filehdr	ecoff.h	/^struct ecoff_filehdr {$/;"	s
ecoff_pdr	ecoff.h	/^typedef struct ecoff_pdr {$/;"	s
ecoff_scnhdr	ecoff.h	/^struct ecoff_scnhdr {$/;"	s
ecoff_symhdr_t	ecoff.h	/^typedef struct ecoff_symhdr_t {$/;"	s
elapsed_time	misc.c	/^elapsed_time(long sec)$/;"	f
end_addr	readfile.c	/^md_addr_t	start_addr, end_addr, main_addr;$/;"	v
entry	ecoff.h	/^  int entry;$/;"	m	struct:ecoff_aouthdr
err_value	eval.c	/^static struct eval_value_t err_value = { et_int, { 0 } };$/;"	v	file:
et_NUM	eval.h	/^  et_NUM$/;"	e	enum:eval_type_t
et_addr	eval.h	/^  et_addr,			\/* address value *\/$/;"	e	enum:eval_type_t
et_double	eval.h	/^  et_double,			\/* double-precision floating point value *\/$/;"	e	enum:eval_type_t
et_float	eval.h	/^  et_float,			\/* single-precision floating point value *\/$/;"	e	enum:eval_type_t
et_int	eval.h	/^  et_int,			\/* signed integer result *\/$/;"	e	enum:eval_type_t
et_qword	eval.h	/^  et_qword,			\/* unsigned qword length integer result *\/$/;"	e	enum:eval_type_t
et_sqword	eval.h	/^  et_sqword,			\/* signed qword length integer result *\/$/;"	e	enum:eval_type_t
et_symbol	eval.h	/^  et_symbol,			\/* non-numeric result (!allowed in exprs)*\/$/;"	e	enum:eval_type_t
et_uint	eval.h	/^  et_uint,			\/* unsigned integer result *\/$/;"	e	enum:eval_type_t
eval_as_addr	eval.c	/^eval_as_addr(struct eval_value_t val)$/;"	f
eval_as_double	eval.c	/^eval_as_double(struct eval_value_t val)$/;"	f
eval_as_float	eval.c	/^eval_as_float(struct eval_value_t val)$/;"	f
eval_as_int	eval.c	/^eval_as_int(struct eval_value_t val)$/;"	f
eval_as_qword	eval.c	/^eval_as_qword(struct eval_value_t val)$/;"	f
eval_as_sqword	eval.c	/^eval_as_sqword(struct eval_value_t val)$/;"	f
eval_as_uint	eval.c	/^eval_as_uint(struct eval_value_t val)$/;"	f
eval_delete	eval.c	/^eval_delete(struct eval_state_t *es)	\/* evaluator to delete *\/$/;"	f
eval_err_str	eval.c	/^char *eval_err_str[ERR_NUM] = {$/;"	v
eval_err_t	eval.h	/^enum eval_err_t {$/;"	g
eval_error	eval.c	/^enum eval_err_t eval_error = ERR_NOERR;$/;"	v
eval_expr	eval.c	/^eval_expr(struct eval_state_t *es,	\/* expression evaluator *\/$/;"	f
eval_ident_t	eval.h	/^(*eval_ident_t)(struct eval_state_t *es); \/* ident string in es->tok_buf *\/$/;"	t
eval_new	eval.c	/^eval_new(eval_ident_t f_eval_ident,	\/* user ident evaluator *\/$/;"	f
eval_print	eval.c	/^eval_print(FILE *stream,		\/* output stream *\/$/;"	f
eval_state_t	eval.h	/^struct eval_state_t {$/;"	s
eval_token_t	eval.h	/^enum eval_token_t {$/;"	g
eval_type_str	eval.c	/^char *eval_type_str[et_NUM] = {$/;"	v
eval_type_t	eval.h	/^enum eval_type_t {$/;"	g
eval_value_t	eval.h	/^struct eval_value_t {$/;"	s
exo_address_t	machine.h	/^typedef qword_t exo_address_t;$/;"	t
exo_float_t	machine.h	/^typedef double exo_float_t;$/;"	t
exo_integer_t	machine.h	/^typedef qword_t exo_integer_t;$/;"	t
expr	eval.c	/^expr(struct eval_state_t *es)		\/* expression evaluator *\/$/;"	f	file:
ext	misc.c	/^  char *ext;$/;"	m	file:
extractl	misc.c	/^extractl(int word,		\/* the word from which to extract *\/$/;"	f
f	machine.h	/^  sfloat_t f[MD_NUM_FREGS];	\/* single-precision floating point view *\/$/;"	m
fBigendian	ecoff.h	/^  unsigned fBigendian :1;$/;"	m	struct:ecoff_fdr
fMerge	ecoff.h	/^  unsigned fMerge :1;$/;"	m	struct:ecoff_fdr
fReadin	ecoff.h	/^  unsigned fReadin :1;$/;"	m	struct:ecoff_fdr
f_add	eval.c	/^f_add(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:
f_div	eval.c	/^f_div(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:
f_eq_zero	eval.c	/^f_eq_zero(struct eval_value_t val1)$/;"	f	file:
f_eval_ident	eval.h	/^  eval_ident_t f_eval_ident;	\/* identifier evaluator *\/$/;"	m	struct:eval_state_t
f_flags	ecoff.h	/^  unsigned short f_flags;$/;"	m	struct:ecoff_filehdr
f_magic	ecoff.h	/^  unsigned short f_magic;$/;"	m	struct:ecoff_filehdr
f_mult	eval.c	/^f_mult(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:
f_neg	eval.c	/^f_neg(struct eval_value_t val1)$/;"	f	file:
f_nscns	ecoff.h	/^  unsigned short f_nscns;$/;"	m	struct:ecoff_filehdr
f_nsyms	ecoff.h	/^  int f_nsyms;$/;"	m	struct:ecoff_filehdr
f_opthdr	ecoff.h	/^  unsigned short f_opthdr;$/;"	m	struct:ecoff_filehdr
f_sub	eval.c	/^f_sub(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:
f_symptr	ecoff.h	/^  int f_symptr;$/;"	m	struct:ecoff_filehdr
f_timdat	ecoff.h	/^  int f_timdat;$/;"	m	struct:ecoff_filehdr
factor	eval.c	/^factor(struct eval_state_t *es)		\/* expression evaluator *\/$/;"	f	file:
fatal	misc.c	/^fatal(char *fmt, ...)$/;"	f
fatal	misc.h	105;"	d
fatal_hook	misc.c	/^fatal_hook(void (*fn)(FILE *stream))	\/* fatal hook function *\/$/;"	f
fcc	machine.h	/^  int fcc;			\/* floating point condition codes *\/$/;"	m
fij	readfile.c	/^FILE *fij;$/;"	v
file	machine.h	/^  enum md_reg_type file;	\/* register file *\/$/;"	m	struct:md_reg_names_t
flags2str	symbol.c	/^flags2str(unsigned int flags)	\/* bfd symbol flags *\/$/;"	f	file:
for_counter	machine.h	571;"	d
for_counter	machine.h	575;"	d
frameoffset	ecoff.h	/^  int frameoffset;$/;"	m	struct:ecoff_pdr
framereg	ecoff.h	/^  short framereg;$/;"	m	struct:ecoff_pdr
fregmask	ecoff.h	/^  int fregmask;$/;"	m	struct:ecoff_pdr
fregoffset	ecoff.h	/^  int fregoffset;$/;"	m	struct:ecoff_pdr
get_next_token	eval.c	/^get_next_token(struct eval_state_t *es)	\/* expression evaluator *\/$/;"	f	file:
getcore	misc.c	/^getcore(int nbytes)$/;"	f
gp_value	ecoff.h	/^  int gp_value;$/;"	m	struct:ecoff_aouthdr
gprmask	ecoff.h	/^  int gprmask;$/;"	m	struct:ecoff_aouthdr
gzclose	misc.c	/^gzclose(FILE *fd)$/;"	f
gzcmds	misc.c	/^} gzcmds[] = {$/;"	v	file:
gzopen	misc.c	/^gzopen(char *fname, char *type)$/;"	f
half_t	host.h	/^typedef unsigned short half_t;		\/* half - 16 bits *\/$/;"	t
hi	machine.h	/^  sword_t hi, lo;		\/* multiplier HI\/LO result registers *\/$/;"	m
hook_fn	misc.c	/^static void (*hook_fn)(FILE *stream) = NULL;$/;"	v	file:
iauxBase	ecoff.h	/^  int iauxBase;$/;"	m	struct:ecoff_fdr
iauxMax	ecoff.h	/^  int iauxMax;$/;"	m	struct:ecoff_symhdr_t
idnMax	ecoff.h	/^  int idnMax;$/;"	m	struct:ecoff_symhdr_t
iextMax	ecoff.h	/^  int iextMax;$/;"	m	struct:ecoff_symhdr_t
ifd	ecoff.h	/^  short ifd;$/;"	m	struct:ecoff_EXTR
ifdMax	ecoff.h	/^  int ifdMax;$/;"	m	struct:ecoff_symhdr_t
iline	ecoff.h	/^  int iline;$/;"	m	struct:ecoff_pdr
ilineBase	ecoff.h	/^  int ilineBase;$/;"	m	struct:ecoff_fdr
ilineMax	ecoff.h	/^  int ilineMax;$/;"	m	struct:ecoff_symhdr_t
index	ecoff.h	/^  unsigned index :20;$/;"	m	struct:ecoff_SYMR
info	misc.h	144;"	d
init_tok_map	eval.c	/^init_tok_map(void)$/;"	f	file:
initialized	symbol.h	/^  int initialized;		\/* initialized? (if data segment) *\/$/;"	m	struct:sym_sym_t
iopt	ecoff.h	/^  int iopt;$/;"	m	struct:ecoff_pdr
ioptBase	ecoff.h	/^  int ioptBase;$/;"	m	struct:ecoff_fdr
ioptMax	ecoff.h	/^  int ioptMax;$/;"	m	struct:ecoff_symhdr_t
ipdFirst	ecoff.h	/^  unsigned short ipdFirst;$/;"	m	struct:ecoff_fdr
ipdMax	ecoff.h	/^  int ipdMax;$/;"	m	struct:ecoff_symhdr_t
is_lib_func	readfile.c	/^is_lib_func(char *func_name)$/;"	f	file:
iss	ecoff.h	/^  int iss;$/;"	m	struct:ecoff_SYMR
issBase	ecoff.h	/^  int issBase;$/;"	m	struct:ecoff_fdr
issExtMax	ecoff.h	/^  int issExtMax;$/;"	m	struct:ecoff_symhdr_t
issMax	ecoff.h	/^  int issMax;$/;"	m	struct:ecoff_symhdr_t
isym	ecoff.h	/^  int isym;$/;"	m	struct:ecoff_pdr
isymBase	ecoff.h	/^  int isymBase;$/;"	m	struct:ecoff_fdr
isymMax	ecoff.h	/^  int isymMax;$/;"	m	struct:ecoff_symhdr_t
l	machine.h	/^  sword_t l[MD_NUM_FREGS];	\/* integer word view *\/$/;"	m
lang	ecoff.h	/^  unsigned lang :5;$/;"	m	struct:ecoff_fdr
largeint_t	misc.c	/^typedef qword_t largeint_t;$/;"	t	file:
largeint_t	misc.c	/^typedef word_t largeint_t;$/;"	t	file:
lastp	eval.h	/^  char *lastp;			\/* save space for token peeks *\/$/;"	m	struct:eval_state_t
ld_text_base	readfile.c	/^md_addr_t	ld_text_base = 0;$/;"	v
ld_text_size	readfile.c	/^unsigned int	ld_text_size = 0;$/;"	v
lnHigh	ecoff.h	/^  int lnHigh;$/;"	m	struct:ecoff_pdr
lnLow	ecoff.h	/^  int lnLow;$/;"	m	struct:ecoff_pdr
lo	machine.h	/^  sword_t hi, lo;		\/* multiplier HI\/LO result registers *\/$/;"	m
local	symbol.h	/^  int local;			\/* compiler local symbol? *\/$/;"	m	struct:sym_sym_t
log_base2	misc.c	/^log_base2(int n)$/;"	f
longjmp	host.h	137;"	d
lookup_addr	readfile.c	/^lookup_addr(char *fname)$/;"	f	file:
magic	ecoff.h	/^  short magic;$/;"	m	struct:ecoff_aouthdr
magic	ecoff.h	/^  short magic;$/;"	m	struct:ecoff_symhdr_t
main	eval.c	/^main(void)$/;"	f
main	main.c	/^main(int argc, char **argv)$/;"	f
main_addr	readfile.c	/^md_addr_t	start_addr, end_addr, main_addr;$/;"	v
md_addr_t	machine.h	/^typedef word_t md_addr_t;$/;"	t
md_amode_NUM	machine.h	/^  md_amode_NUM$/;"	e	enum:md_amode_type
md_amode_disp	machine.h	/^  md_amode_disp,	\/* (reg + const) addressing *\/$/;"	e	enum:md_amode_type
md_amode_fp	machine.h	/^  md_amode_fp,		\/* stack access through frame pointer *\/$/;"	e	enum:md_amode_type
md_amode_gp	machine.h	/^  md_amode_gp,		\/* global data access through global pointer *\/$/;"	e	enum:md_amode_type
md_amode_imm	machine.h	/^  md_amode_imm,		\/* immediate addressing mode *\/$/;"	e	enum:md_amode_type
md_amode_rr	machine.h	/^  md_amode_rr,		\/* (reg + reg) addressing *\/$/;"	e	enum:md_amode_type
md_amode_sp	machine.h	/^  md_amode_sp,		\/* stack access through stack pointer *\/$/;"	e	enum:md_amode_type
md_amode_str	machine.c	/^char *md_amode_str[md_amode_NUM] =$/;"	v
md_amode_type	machine.h	/^enum md_amode_type {$/;"	g
md_crc_regs	machine.c	/^md_crc_regs(struct regs_t *regs)$/;"	f
md_ctrl_t	machine.h	/^} md_ctrl_t;$/;"	t
md_fault_access	machine.h	/^  md_fault_access,		\/* storage access fault *\/$/;"	e	enum:md_fault_type
md_fault_alignment	machine.h	/^  md_fault_alignment,		\/* storage alignment fault *\/$/;"	e	enum:md_fault_type
md_fault_break	machine.h	/^  md_fault_break,		\/* BREAK instruction fault *\/$/;"	e	enum:md_fault_type
md_fault_div0	machine.h	/^  md_fault_div0,		\/* division by zero fault *\/$/;"	e	enum:md_fault_type
md_fault_internal	machine.h	/^  md_fault_internal		\/* internal S\/W fault *\/$/;"	e	enum:md_fault_type
md_fault_none	machine.h	/^  md_fault_none = 0,		\/* no fault *\/$/;"	e	enum:md_fault_type
md_fault_overflow	machine.h	/^  md_fault_overflow,		\/* signed arithmetic overflow fault *\/$/;"	e	enum:md_fault_type
md_fault_type	machine.h	/^enum md_fault_type {$/;"	g
md_fault_unimpl	machine.h	/^  md_fault_unimpl,		\/* unimplemented instruction fault *\/$/;"	e	enum:md_fault_type
md_fpr_t	machine.h	/^} md_fpr_t;$/;"	t
md_fu2name	machine.c	/^char *md_fu2name[NUM_FU_CLASSES] = {$/;"	v
md_fu_class	machine.h	/^enum md_fu_class {$/;"	g
md_gpr_t	machine.h	/^typedef sword_t md_gpr_t[MD_NUM_IREGS];$/;"	t
md_init_decoder	machine.c	/^md_init_decoder(void)$/;"	f
md_inst_t	machine.h	/^} md_inst_t;$/;"	t
md_lr_masks	machine.c	/^word_t md_lr_masks[] = {$/;"	v
md_mask2op	machine.c	/^enum md_opcode md_mask2op[MD_MAX_MASK+1];$/;"	v
md_op2flags	machine.c	/^unsigned int md_op2flags[OP_MAX] = {$/;"	v
md_op2format	machine.c	/^char *md_op2format[OP_MAX] = {$/;"	v
md_op2fu	machine.c	/^enum md_fu_class md_op2fu[OP_MAX] = {$/;"	v
md_op2name	machine.c	/^char *md_op2name[OP_MAX] = {$/;"	v
md_opcode	machine.h	/^enum md_opcode {$/;"	g
md_print_creg	machine.c	/^md_print_creg(md_ctrl_t regs, int reg, FILE *stream)$/;"	f
md_print_cregs	machine.c	/^md_print_cregs(md_ctrl_t regs, FILE *stream)$/;"	f
md_print_fpreg	machine.c	/^md_print_fpreg(md_fpr_t regs, int reg, FILE *stream)$/;"	f
md_print_fpregs	machine.c	/^md_print_fpregs(md_fpr_t regs, FILE *stream)$/;"	f
md_print_insn	machine.c	/^md_print_insn(md_inst_t inst,		\/* instruction to disassemble *\/$/;"	f
md_print_ireg	machine.c	/^md_print_ireg(md_gpr_t regs, int reg, FILE *stream)$/;"	f
md_print_iregs	machine.c	/^md_print_iregs(md_gpr_t regs, FILE *stream)$/;"	f
md_reg_name	machine.c	/^md_reg_name(enum md_reg_type rt, int reg)$/;"	f
md_reg_names	machine.c	/^struct md_reg_names_t md_reg_names[] =$/;"	v
md_reg_names	machine.h	/^enum md_reg_names {$/;"	g
md_reg_names_t	machine.h	/^struct md_reg_names_t {$/;"	s
md_reg_obj	machine.c	/^md_reg_obj(struct regs_t *regs,			\/* registers to access *\/$/;"	f
md_reg_type	machine.h	/^enum md_reg_type {$/;"	g
md_xor_regs	machine.c	/^md_xor_regs(struct regs_t *regs)$/;"	f
my_eval_ident	eval.c	/^my_eval_ident(struct eval_state_t *es)$/;"	f
myatoq	misc.c	/^myatoq(char *nptr, char **endp, int base)$/;"	f
myatosq	misc.c	/^myatosq(char *nptr, char **endp, int base)$/;"	f
myfprintf	misc.c	/^myfprintf(FILE *stream, char *format, ...)$/;"	f
myrand	misc.c	/^myrand(void)			\/* returns random number *\/$/;"	f
mysprintf	misc.c	/^mysprintf(char *obuf, char *format, ...)$/;"	f
mysrand	misc.c	/^mysrand(unsigned int seed)	\/* random number generator seed *\/$/;"	f
mystrdup	misc.c	/^mystrdup(char *s)		\/* string to duplicate to heap storage *\/$/;"	f
mystricmp	misc.c	/^mystricmp(char *s1, char *s2)	\/* strings to compare, case insensitive *\/$/;"	f
mystrrchr	misc.c	/^mystrrchr(char *s, char c)$/;"	f
myvfprintf	misc.c	/^myvfprintf(FILE *stream, char *format, va_list v)$/;"	f
myvsprintf	misc.c	/^myvsprintf(char *obuf, char *format, va_list v)$/;"	f
name	symbol.h	/^  char *name;			\/* symbol name *\/$/;"	m	struct:sym_sym_t
ncmp	symbol.c	/^ncmp(struct sym_sym_t **sym1, struct sym_sym_t **sym2)$/;"	f	file:
nij	readfile.c	/^int   nij = 0; \/\/number of indirect jump$/;"	v
num_procs	readfile.c	/^int		num_procs = 0;$/;"	v
obj	readfile.c	/^char obj[100];$/;"	v
p	eval.h	/^  char *p;			\/* ptr to next char to consume from expr *\/$/;"	m	struct:eval_state_t
panic	misc.c	/^panic(char *fmt, ...)$/;"	f
panic	misc.h	119;"	d
pcreg	ecoff.h	/^  short pcreg;$/;"	m	struct:ecoff_pdr
peek_next_token	eval.c	/^peek_next_token(struct eval_state_t *es) \/* expression evalutor *\/$/;"	f	file:
peek_tok	eval.h	/^  enum eval_token_t peek_tok;	\/* peek buffer, for one token look-ahead *\/$/;"	m	struct:eval_state_t
procs_addr	readfile.c	/^md_addr_t	*procs_addr = NULL; \/\/ start addresses of procedures$/;"	v
pub	symbol.h	/^  int pub;			\/* externally visible? *\/$/;"	m	struct:sym_sym_t
qword_t	host.h	/^typedef unsigned __int64 qword_t;	\/* qword - 64 bits *\/$/;"	t
qword_t	host.h	/^typedef unsigned long long qword_t;	\/* qword - 64 bits *\/$/;"	t
qword_t	host.h	/^typedef unsigned long qword_t;		\/* qword - 64 bits *\/$/;"	t
read_symbol_table	readfile.c	/^void read_symbol_table(char *fname, md_inst_t *code)$/;"	f
read_text_head	readfile.c	/^read_text_head(char *fname)$/;"	f	file:
readcode	readfile.c	/^readcode(char *fname)$/;"	f
reg	machine.h	/^  int reg;			\/* register index *\/$/;"	m	struct:md_reg_names_t
regmask	ecoff.h	/^  int regmask;$/;"	m	struct:ecoff_pdr
regoffset	ecoff.h	/^  int regoffset;$/;"	m	struct:ecoff_pdr
regs_C	regs.h	/^  md_ctrl_t regs_C;		\/* control register file *\/$/;"	m	struct:regs_t
regs_F	regs.h	/^  md_fpr_t regs_F;		\/* floating point register file *\/$/;"	m	struct:regs_t
regs_NPC	regs.h	/^  md_addr_t regs_NPC;		\/* next-cycle program counter *\/$/;"	m	struct:regs_t
regs_PC	regs.h	/^  md_addr_t regs_PC;		\/* program counter *\/$/;"	m	struct:regs_t
regs_R	regs.h	/^  md_gpr_t regs_R;		\/* (signed) integer register file *\/$/;"	m	struct:regs_t
regs_t	regs.h	/^struct regs_t {$/;"	s
reserved	ecoff.h	/^  short reserved;$/;"	m	struct:ecoff_EXTR
reserved	ecoff.h	/^  unsigned reserved :1;$/;"	m	struct:ecoff_SYMR
reserved	ecoff.h	/^  unsigned reserved :24;$/;"	m	struct:ecoff_fdr
result_type	eval.c	/^result_type(enum eval_type_t t1,	\/* left operand type *\/$/;"	f	file:
rfdBase	ecoff.h	/^  int rfdBase;$/;"	m	struct:ecoff_fdr
rss	ecoff.h	/^  int rss;$/;"	m	struct:ecoff_fdr
rt_NPC	machine.h	/^  rt_NPC,		\/* next program counter *\/$/;"	e	enum:md_reg_type
rt_NUM	machine.h	/^  rt_NUM$/;"	e	enum:md_reg_type
rt_PC	machine.h	/^  rt_PC,		\/* program counter *\/$/;"	e	enum:md_reg_type
rt_ctrl	machine.h	/^  rt_ctrl,		\/* control register *\/$/;"	e	enum:md_reg_type
rt_dpr	machine.h	/^  rt_dpr,		\/* double-precision floating pointer register *\/$/;"	e	enum:md_reg_type
rt_fpr	machine.h	/^  rt_fpr,		\/* single-precision floating pointer register *\/$/;"	e	enum:md_reg_type
rt_gpr	machine.h	/^  rt_gpr,		\/* general purpose register *\/$/;"	e	enum:md_reg_type
rt_lpr	machine.h	/^  rt_lpr,		\/* integer-precision floating pointer register *\/$/;"	e	enum:md_reg_type
s_flags	ecoff.h	/^  int s_flags;$/;"	m	struct:ecoff_scnhdr
s_lnnoptr	ecoff.h	/^  int s_lnnoptr;$/;"	m	struct:ecoff_scnhdr
s_name	ecoff.h	/^  char s_name[8];$/;"	m	struct:ecoff_scnhdr
s_nlnno	ecoff.h	/^  unsigned short s_nlnno;$/;"	m	struct:ecoff_scnhdr
s_nreloc	ecoff.h	/^  unsigned short s_nreloc;$/;"	m	struct:ecoff_scnhdr
s_paddr	ecoff.h	/^  int s_paddr;$/;"	m	struct:ecoff_scnhdr
s_relptr	ecoff.h	/^  int s_relptr;$/;"	m	struct:ecoff_scnhdr
s_scnptr	ecoff.h	/^  int s_scnptr;$/;"	m	struct:ecoff_scnhdr
s_size	ecoff.h	/^  int s_size;$/;"	m	struct:ecoff_scnhdr
s_vaddr	ecoff.h	/^  int s_vaddr;$/;"	m	struct:ecoff_scnhdr
save_ij	readfile.c	/^void save_ij(){$/;"	f
sbyte_t	host.h	/^typedef signed char sbyte_t;$/;"	t
sc	ecoff.h	/^  unsigned sc :5;$/;"	m	struct:ecoff_SYMR
sc_counter	machine.h	570;"	d
sc_counter	machine.h	574;"	d
sdb_NUM	symbol.h	/^  sdb_NUM$/;"	e	enum:sym_db_t
sdb_any	symbol.h	/^  sdb_any,			\/* search all symbols *\/$/;"	e	enum:sym_db_t
sdb_data	symbol.h	/^  sdb_data,			\/* search data symbols *\/$/;"	e	enum:sym_db_t
sdb_text	symbol.h	/^  sdb_text,			\/* search text symbols *\/$/;"	e	enum:sym_db_t
seg	symbol.h	/^  enum sym_seg_t seg;		\/* symbol segment *\/$/;"	m	struct:sym_sym_t
setjmp	host.h	136;"	d
sfloat_t	host.h	/^typedef float sfloat_t;			\/* single-precision float - 32 bits *\/$/;"	t
shalf_t	host.h	/^typedef signed short shalf_t;$/;"	t
size	symbol.h	/^  int size;			\/* bytes to next symbol *\/$/;"	m	struct:sym_sym_t
slargeint_t	misc.c	/^typedef sqword_t slargeint_t;$/;"	t	file:
slargeint_t	misc.c	/^typedef sword_t slargeint_t;$/;"	t	file:
sqword_t	host.h	/^typedef signed __int64 sqword_t;$/;"	t
sqword_t	host.h	/^typedef signed long long sqword_t;$/;"	t
sqword_t	host.h	/^typedef signed long sqword_t;$/;"	t
ss_NUM	symbol.h	/^  ss_NUM$/;"	e	enum:sym_seg_t
ss_data	symbol.h	/^  ss_data,			\/* data segment symbol *\/$/;"	e	enum:sym_seg_t
ss_text	symbol.h	/^  ss_text,			\/* text segment symbol *\/$/;"	e	enum:sym_seg_t
st	ecoff.h	/^  unsigned st :6;$/;"	m	struct:ecoff_SYMR
start_addr	readfile.c	/^md_addr_t	start_addr, end_addr, main_addr;$/;"	v
stat_reg_addr	machine.h	579;"	d
stat_reg_counter	machine.h	569;"	d
stat_reg_counter	machine.h	573;"	d
stestit	misc.c	/^stestit(char *s)$/;"	f
str	machine.h	/^  char *str;			\/* register name *\/$/;"	m	struct:md_reg_names_t
strtoul	eval.c	62;"	d	file:
strtoul	misc.h	224;"	d
sword_t	host.h	/^typedef signed int sword_t;$/;"	t
sym_bind_addr	symbol.c	/^sym_bind_addr(md_addr_t addr,		\/* address of symbol to locate *\/$/;"	f
sym_bind_name	symbol.c	/^sym_bind_name(char *name,			\/* symbol name to locate *\/$/;"	f
sym_datasyms	symbol.c	/^struct sym_sym_t **sym_datasyms = NULL;$/;"	v
sym_datasyms_by_name	symbol.c	/^struct sym_sym_t **sym_datasyms_by_name = NULL;$/;"	v
sym_db	symbol.c	/^struct sym_sym_t *sym_db = NULL;$/;"	v
sym_db_t	symbol.h	/^enum sym_db_t {$/;"	g
sym_dumpstate	symbol.c	/^sym_dumpstate(FILE *fd)			\/* output stream *\/$/;"	f
sym_dumpsym	symbol.c	/^sym_dumpsym(struct sym_sym_t *sym,	\/* symbol to display *\/$/;"	f
sym_dumpsyms	symbol.c	/^sym_dumpsyms(FILE *fd)			\/* output stream *\/$/;"	f
sym_dumptextsyms	symbol.c	/^sym_dumptextsyms(FILE *fd)			\/* output stream *\/$/;"	f
sym_loadsyms	symbol.c	/^sym_loadsyms(char *fname,	\/* file name containing symbols *\/$/;"	f
sym_map	eval.c	/^static struct sym_map_t sym_map[] = {$/;"	v	file:
sym_map_t	eval.c	/^struct sym_map_t {$/;"	s	file:
sym_ndatasyms	symbol.c	/^int sym_ndatasyms = 0;$/;"	v
sym_nsyms	symbol.c	/^int sym_nsyms = 0;$/;"	v
sym_ntextsyms	symbol.c	/^int sym_ntextsyms = 0;$/;"	v
sym_seg_t	symbol.h	/^enum sym_seg_t {$/;"	g
sym_sym_t	symbol.h	/^struct sym_sym_t {$/;"	s
sym_syms	symbol.c	/^struct sym_sym_t **sym_syms = NULL;$/;"	v
sym_syms_by_name	symbol.c	/^struct sym_sym_t **sym_syms_by_name = NULL;$/;"	v
sym_textsyms	symbol.c	/^struct sym_sym_t **sym_textsyms = NULL;$/;"	v
sym_textsyms_by_name	symbol.c	/^struct sym_sym_t **sym_textsyms_by_name = NULL;$/;"	v
symbol	eval.c	/^  char *symbol;$/;"	m	struct:sym_map_t	file:
syms_loaded	symbol.c	/^static int syms_loaded = FALSE;$/;"	v	file:
term	eval.c	/^term(struct eval_state_t *es)		\/* expression evaluator *\/$/;"	f	file:
testit	misc.c	/^testit(char *s)$/;"	f
text_entry	readfile.c	/^unsigned	text_entry;$/;"	v
text_offset	readfile.c	/^unsigned	text_offset;$/;"	v
text_start	ecoff.h	/^  int text_start;$/;"	m	struct:ecoff_aouthdr
tick_t	host.h	/^typedef dfloat_t tick_t;$/;"	t
tick_t	host.h	/^typedef sqword_t tick_t;		\/* NOTE: unsigned breaks caches *\/$/;"	t
tok_buf	eval.h	/^  char tok_buf[512];		\/* text of last token returned *\/$/;"	m	struct:eval_state_t
tok_const	eval.h	/^  tok_const,		\/* numeric literals *\/$/;"	e	enum:eval_token_t
tok_cparen	eval.h	/^  tok_cparen,		\/* `)' *\/$/;"	e	enum:eval_token_t
tok_div	eval.h	/^  tok_div,		\/* `\/' *\/$/;"	e	enum:eval_token_t
tok_eof	eval.h	/^  tok_eof,		\/* end of file *\/$/;"	e	enum:eval_token_t
tok_ident	eval.h	/^  tok_ident,		\/* user-valued identifiers *\/$/;"	e	enum:eval_token_t
tok_invalid	eval.h	/^  tok_invalid		\/* unrecognized token *\/$/;"	e	enum:eval_token_t
tok_map	eval.c	/^static enum eval_token_t tok_map[256];$/;"	v	file:
tok_map_initialized	eval.c	/^static int tok_map_initialized = FALSE;$/;"	v	file:
tok_minus	eval.h	/^  tok_minus,		\/* `-' *\/$/;"	e	enum:eval_token_t
tok_mult	eval.h	/^  tok_mult,		\/* `*' *\/$/;"	e	enum:eval_token_t
tok_oparen	eval.h	/^  tok_oparen,		\/* `(' *\/$/;"	e	enum:eval_token_t
tok_plus	eval.h	/^  tok_plus,		\/* `+' *\/$/;"	e	enum:eval_token_t
tok_whitespace	eval.h	/^  tok_whitespace,	\/* ` ', `\\t', `\\n' *\/$/;"	e	enum:eval_token_t
tsize	ecoff.h	/^  int tsize;$/;"	m	struct:ecoff_aouthdr
type	eval.h	/^  enum eval_type_t type;		\/* type of expression value *\/$/;"	m	struct:eval_value_t
type	misc.c	/^  char *type;$/;"	m	file:
user_ptr	eval.h	/^  void *user_ptr;		\/* user-supplied argument pointer *\/$/;"	m	struct:eval_state_t
value	ecoff.h	/^  int value;$/;"	m	struct:ecoff_SYMR
value	eval.c	/^  struct eval_value_t *value;$/;"	m	struct:sym_map_t	file:
value	eval.h	/^  } value;$/;"	m	struct:eval_value_t
verbose	misc.c	/^int verbose = FALSE;$/;"	v
vstamp	ecoff.h	/^  short vstamp;$/;"	m	struct:ecoff_aouthdr
vstamp	ecoff.h	/^  short vstamp;$/;"	m	struct:ecoff_symhdr_t
warn	misc.h	132;"	d
word_t	host.h	/^typedef unsigned int word_t;		\/* word - 32 bits *\/$/;"	t
xtestit	misc.c	/^xtestit(char *s)$/;"	f
